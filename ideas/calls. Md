Yes—this is the key decision at the heart of Garden:

> Do we preserve multiple instances of the same variable across calls (like a debugger)?
Or do we always have exactly one value per named expression, so the dev environment always shows the “current” value in scope?



You’re leaning toward the second—and I think you’re right.


---

Garden Principle: One Value Per Name

> Every named expression has one cached value.
If it’s re-evaluated, the value is updated.
At any point, every name has exactly one visible, current value.



This gives you a very specific magic:

Dev-Time and Run-Time Collapse

Every time you write let x = ..., you can see what x is—immediately.

Your program is not a function that runs; it’s a garden of live values, constantly growing and rebalancing.



---

What Happens in Function Calls?

Let’s say you define:

fn square(x) {
  let result = x * x;
  return result;
}

let a = square(3);
let b = square(4);

Option A: Store square/result for each call

square/3/result = 9

square/4/result = 16

But now what’s square/result? You’d need a UI that surfaces all inhabitations.


Option B (Your Proposal): square/result always reflects the last call

square/result = 16 (after b = square(4))

result in scope always has a value

This makes Garden feel like a REPL merged with a debugger merged with a spreadsheet



---

Benefits of Single Inhabitation (Your Direction)

1. Simpler Mental Model

Every name has one value. Period.

let result = ... always maps to exactly one thing.



2. Live Feedback Loop

Change square(3) to square(9) → result updates instantly.

Like hot reload with memory.



3. Zero UI Complexity

No need for call frame navigation.

Everything visible in one screen.



4. Matches Intuition of Editing Code

You’re not exploring a trace.

You’re shaping a living program, where every name has a current meaning.





---

So How Do You Handle Multiple Calls?

Simple:

> Only the last call to a function populates the scoped bindings.
Earlier calls are overwritten.



This might seem limiting—but in practice, it’s exactly what you want when editing:

let user = { "name": "Alice", "scores": [80, 90, 100] };
let summary = describe_user(user);

You edit user → summary and all intermediate values update. You don't need multiple versions. You're gardening one version of the program.


---

Optional Future Direction

You could allow multiple branches later:

Add an @trace annotation to track all calls to a function.

Useful for testing or visualization, but not the default.



---

Summary: Garden’s Identity Model

> Each named expression has exactly one cached value: the most recent one.
This makes the entire program introspectable at once.
You don’t debug after you run—you just see.



That gives you a dev flow closer to sublime fusion of IDE, REPL, spreadsheet, and program. All because you chose to say: “Every name has one value. That’s the map.”

Would you like a .value export mockup or TUI layout based on this model next?
